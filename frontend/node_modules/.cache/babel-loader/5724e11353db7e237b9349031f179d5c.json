{"ast":null,"code":"import React, { useContext, useEffect } from 'react';\nimport { defineCustomElements } from '@ionic/core/loader';\nimport { addIcons } from 'ionicons';\nimport { close, reorder, menu, arrowForward, arrowBack, arrowDown, search, closeCircle } from 'ionicons/icons';\nimport { isPlatform as isPlatform$1, getPlatforms as getPlatforms$1, alertController, loadingController, toastController, pickerController, actionSheetController, modalController, popoverController } from '@ionic/core';\nexport { setupConfig } from '@ionic/core';\nimport { __rest } from 'tslib';\nimport ReactDom from 'react-dom';\nconst IonLifeCycleContext =\n/*@__PURE__*/\nReact.createContext({\n  onIonViewWillEnter: () => {\n    return;\n  },\n  ionViewWillEnter: () => {\n    return;\n  },\n  onIonViewDidEnter: () => {\n    return;\n  },\n  ionViewDidEnter: () => {\n    return;\n  },\n  onIonViewWillLeave: () => {\n    return;\n  },\n  ionViewWillLeave: () => {\n    return;\n  },\n  onIonViewDidLeave: () => {\n    return;\n  },\n  ionViewDidLeave: () => {\n    return;\n  }\n});\nconst DefaultIonLifeCycleContext = class {\n  constructor() {\n    this.ionViewWillEnterCallbacks = [];\n    this.ionViewDidEnterCallbacks = [];\n    this.ionViewWillLeaveCallbacks = [];\n    this.ionViewDidLeaveCallbacks = [];\n  }\n\n  onIonViewWillEnter(callback) {\n    this.ionViewWillEnterCallbacks.push(callback);\n  }\n\n  ionViewWillEnter() {\n    this.ionViewWillEnterCallbacks.forEach(cb => cb());\n  }\n\n  onIonViewDidEnter(callback) {\n    this.ionViewDidEnterCallbacks.push(callback);\n  }\n\n  ionViewDidEnter() {\n    this.ionViewDidEnterCallbacks.forEach(cb => cb());\n  }\n\n  onIonViewWillLeave(callback) {\n    this.ionViewWillLeaveCallbacks.push(callback);\n  }\n\n  ionViewWillLeave() {\n    this.ionViewWillLeaveCallbacks.forEach(cb => cb());\n  }\n\n  onIonViewDidLeave(callback) {\n    this.ionViewDidLeaveCallbacks.push(callback);\n  }\n\n  ionViewDidLeave() {\n    this.ionViewDidLeaveCallbacks.forEach(cb => cb());\n    this.componentCanBeDestroyed();\n  }\n\n  onComponentCanBeDestroyed(callback) {\n    this.componentCanBeDestroyedCallback = callback;\n  }\n\n  componentCanBeDestroyed() {\n    if (this.componentCanBeDestroyedCallback) {\n      this.componentCanBeDestroyedCallback();\n    }\n  }\n\n};\n\nconst withIonLifeCycle = WrappedComponent => {\n  return class IonLifeCycle extends React.Component {\n    constructor(props) {\n      super(props);\n      this.componentRef = React.createRef();\n    }\n\n    componentDidMount() {\n      const element = this.componentRef.current;\n      this.context.onIonViewWillEnter(() => {\n        if (element && element.ionViewWillEnter) {\n          element.ionViewWillEnter();\n        }\n      });\n      this.context.onIonViewDidEnter(() => {\n        if (element && element.ionViewDidEnter) {\n          element.ionViewDidEnter();\n        }\n      });\n      this.context.onIonViewWillLeave(() => {\n        if (element && element.ionViewWillLeave) {\n          element.ionViewWillLeave();\n        }\n      });\n      this.context.onIonViewDidLeave(() => {\n        if (element && element.ionViewDidLeave) {\n          element.ionViewDidLeave();\n        }\n      });\n    }\n\n    render() {\n      return React.createElement(IonLifeCycleContext.Consumer, null, context => {\n        this.context = context;\n        return React.createElement(WrappedComponent, Object.assign({\n          ref: this.componentRef\n        }, this.props));\n      });\n    }\n\n  };\n};\n\nconst useIonViewWillEnter = callback => {\n  const context = useContext(IonLifeCycleContext);\n  useEffect(() => {\n    context.onIonViewWillEnter(callback);\n  }, []);\n};\n\nconst useIonViewDidEnter = callback => {\n  const context = useContext(IonLifeCycleContext);\n  useEffect(() => {\n    context.onIonViewDidEnter(callback);\n  }, []);\n};\n\nconst useIonViewWillLeave = callback => {\n  const context = useContext(IonLifeCycleContext);\n  useEffect(() => {\n    context.onIonViewWillLeave(callback);\n  }, []);\n};\n\nconst useIonViewDidLeave = callback => {\n  const context = useContext(IonLifeCycleContext);\n  useEffect(() => {\n    context.onIonViewDidLeave(callback);\n  }, []);\n};\n\nconst NavContext =\n/*@__PURE__*/\nReact.createContext({\n  getPageManager: () => undefined,\n  getStackManager: () => undefined,\n  goBack: defaultHref => {\n    if (defaultHref !== undefined) {\n      window.location.pathname = defaultHref;\n    } else {\n      window.history.back();\n    }\n  },\n  navigate: path => {\n    window.location.pathname = path;\n  },\n  tabNavigate: () => undefined,\n  hasIonicRouter: () => false,\n  registerIonPage: () => undefined,\n  currentPath: undefined\n});\n\nconst dashToPascalCase = str => str.toLowerCase().split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');\n\nconst camelToDashCase = str => str.replace(/([A-Z])/g, m => \"-\".concat(m[0].toLowerCase()));\n\nconst attachProps = (node, newProps, oldProps = {}) => {\n  // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n  if (node instanceof Element) {\n    // add any classes in className to the class list\n    const className = getClassName(node.classList, newProps, oldProps);\n\n    if (className !== '') {\n      node.className = className;\n    }\n\n    Object.keys(newProps).forEach(name => {\n      if (name === 'children' || name === 'style' || name === 'ref' || name === 'class' || name === 'className' || name === 'forwardedRef') {\n        return;\n      }\n\n      if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n        const eventName = name.substring(2);\n        const eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n\n        if (!isCoveredByReact(eventNameLc)) {\n          syncEvent(node, eventNameLc, newProps[name]);\n        }\n      } else {\n        node[name] = newProps[name];\n        const propType = typeof newProps[name];\n\n        if (propType === 'string') {\n          node.setAttribute(camelToDashCase(name), newProps[name]);\n        } else {\n          node[name] = newProps[name];\n        }\n      }\n    });\n  }\n};\n\nconst getClassName = (classList, newProps, oldProps) => {\n  const newClassProp = newProps.className || newProps.class;\n  const oldClassProp = oldProps.className || oldProps.class; // map the classes to Maps for performance\n\n  const currentClasses = arrayToMap(classList);\n  const incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n  const oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n  const finalClassNames = []; // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n\n  currentClasses.forEach(currentClass => {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(s => finalClassNames.push(s));\n  return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\n\n\nconst isCoveredByReact = (eventNameSuffix, doc = document) => {\n  const eventName = 'on' + eventNameSuffix;\n  let isSupported = eventName in doc;\n\n  if (!isSupported) {\n    const element = doc.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n};\n\nconst syncEvent = (node, eventName, newEventHandler) => {\n  const eventStore = node.__events || (node.__events = {});\n  const oldEventHandler = eventStore[eventName]; // Remove old listener so they don't double up.\n\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  } // Bind new listener.\n\n\n  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n    if (newEventHandler) {\n      newEventHandler.call(this, e);\n    }\n  });\n};\n\nconst arrayToMap = arr => {\n  const map = new Map();\n  arr.forEach(s => map.set(s, s));\n  return map;\n};\n\nconst createForwardRef = (ReactComponent, displayName) => {\n  const forwardRef = (props, ref) => {\n    return React.createElement(ReactComponent, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  };\n\n  forwardRef.displayName = displayName;\n  return React.forwardRef(forwardRef);\n};\n\nconst isPlatform = platform => {\n  return isPlatform$1(window, platform);\n};\n\nconst getPlatforms = () => {\n  return getPlatforms$1(window);\n};\n\nconst getConfig = () => {\n  if (typeof window !== 'undefined') {\n    const Ionic = window.Ionic;\n\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n\n  return null;\n};\n\nconst createReactComponent = (tagName, routerLinkComponent = false) => {\n  const displayName = dashToPascalCase(tagName);\n  const ReactComponent = class extends React.Component {\n    constructor(props) {\n      super(props);\n\n      this.handleClick = e => {\n        const _this$props = this.props,\n              routerLink = _this$props.routerLink,\n              routerDirection = _this$props.routerDirection;\n\n        if (routerLink !== undefined) {\n          e.preventDefault();\n          this.context.navigate(routerLink, routerDirection);\n        }\n      };\n    }\n\n    componentDidMount() {\n      this.componentDidUpdate(this.props);\n    }\n\n    componentDidUpdate(prevProps) {\n      const node = ReactDom.findDOMNode(this);\n      attachProps(node, this.props, prevProps);\n    }\n\n    render() {\n      const _a = this.props,\n            children = _a.children,\n            forwardedRef = _a.forwardedRef,\n            style = _a.style,\n            className = _a.className,\n            ref = _a.ref,\n            cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n\n      const propsToPass = Object.keys(cProps).reduce((acc, name) => {\n        if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n          const eventName = name.substring(2).toLowerCase();\n\n          if (isCoveredByReact(eventName)) {\n            acc[name] = cProps[name];\n          }\n        }\n\n        return acc;\n      }, {});\n      const newProps = Object.assign({}, propsToPass, {\n        ref: forwardedRef,\n        style\n      });\n\n      if (routerLinkComponent) {\n        if (this.props.routerLink && !this.props.href) {\n          newProps.href = this.props.routerLink;\n        }\n\n        if (newProps.onClick) {\n          const oldClick = newProps.onClick;\n\n          newProps.onClick = e => {\n            oldClick(e);\n\n            if (!e.defaultPrevented) {\n              this.handleClick(e);\n            }\n          };\n        } else {\n          newProps.onClick = this.handleClick;\n        }\n      }\n\n      return React.createElement(tagName, newProps, children);\n    }\n\n    static get displayName() {\n      return displayName;\n    }\n\n    static get contextType() {\n      return NavContext;\n    }\n\n  };\n  return createForwardRef(ReactComponent, displayName);\n}; // ionicons\n\n\nconst IonIcon =\n/*@__PURE__*/\ncreateReactComponent('ion-icon'); // ionic/core\n\nconst IonApp =\n/*@__PURE__*/\ncreateReactComponent('ion-app');\nconst IonTab =\n/*@__PURE__*/\ncreateReactComponent('ion-tab');\nconst IonTabButton =\n/*@__PURE__*/\ncreateReactComponent('ion-tab-button');\nconst IonRouterLink =\n/*@__PURE__*/\ncreateReactComponent('ion-router-link', true);\nconst IonAvatar =\n/*@__PURE__*/\ncreateReactComponent('ion-avatar');\nconst IonBackdrop =\n/*@__PURE__*/\ncreateReactComponent('ion-backdrop');\nconst IonBadge =\n/*@__PURE__*/\ncreateReactComponent('ion-badge');\nconst IonButton =\n/*@__PURE__*/\ncreateReactComponent('ion-button', true);\nconst IonButtons =\n/*@__PURE__*/\ncreateReactComponent('ion-buttons');\nconst IonCard =\n/*@__PURE__*/\ncreateReactComponent('ion-card', true);\nconst IonCardContent =\n/*@__PURE__*/\ncreateReactComponent('ion-card-content');\nconst IonCardHeader =\n/*@__PURE__*/\ncreateReactComponent('ion-card-header');\nconst IonCardSubtitle =\n/*@__PURE__*/\ncreateReactComponent('ion-card-subtitle');\nconst IonCardTitle =\n/*@__PURE__*/\ncreateReactComponent('ion-card-title');\nconst IonCheckbox =\n/*@__PURE__*/\ncreateReactComponent('ion-checkbox');\nconst IonCol =\n/*@__PURE__*/\ncreateReactComponent('ion-col');\nconst IonContent =\n/*@__PURE__*/\ncreateReactComponent('ion-content');\nconst IonChip =\n/*@__PURE__*/\ncreateReactComponent('ion-chip');\nconst IonDatetime =\n/*@__PURE__*/\ncreateReactComponent('ion-datetime');\nconst IonFab =\n/*@__PURE__*/\ncreateReactComponent('ion-fab');\nconst IonFabButton =\n/*@__PURE__*/\ncreateReactComponent('ion-fab-button', true);\nconst IonFabList =\n/*@__PURE__*/\ncreateReactComponent('ion-fab-list');\nconst IonFooter =\n/*@__PURE__*/\ncreateReactComponent('ion-footer');\nconst IonGrid =\n/*@__PURE__*/\ncreateReactComponent('ion-grid');\nconst IonHeader =\n/*@__PURE__*/\ncreateReactComponent('ion-header');\nconst IonImg =\n/*@__PURE__*/\ncreateReactComponent('ion-img');\nconst IonInfiniteScroll =\n/*@__PURE__*/\ncreateReactComponent('ion-infinite-scroll');\nconst IonInfiniteScrollContent =\n/*@__PURE__*/\ncreateReactComponent('ion-infinite-scroll-content');\nconst IonInput =\n/*@__PURE__*/\ncreateReactComponent('ion-input');\nconst IonItem =\n/*@__PURE__*/\ncreateReactComponent('ion-item', true);\nconst IonItemDivider =\n/*@__PURE__*/\ncreateReactComponent('ion-item-divider');\nconst IonItemGroup =\n/*@__PURE__*/\ncreateReactComponent('ion-item-group');\nconst IonItemOption =\n/*@__PURE__*/\ncreateReactComponent('ion-item-option', true);\nconst IonItemOptions =\n/*@__PURE__*/\ncreateReactComponent('ion-item-options');\nconst IonItemSliding =\n/*@__PURE__*/\ncreateReactComponent('ion-item-sliding');\nconst IonLabel =\n/*@__PURE__*/\ncreateReactComponent('ion-label');\nconst IonList =\n/*@__PURE__*/\ncreateReactComponent('ion-list');\nconst IonListHeader =\n/*@__PURE__*/\ncreateReactComponent('ion-list-header');\nconst IonMenu =\n/*@__PURE__*/\ncreateReactComponent('ion-menu');\nconst IonMenuButton =\n/*@__PURE__*/\ncreateReactComponent('ion-menu-button');\nconst IonMenuToggle =\n/*@__PURE__*/\ncreateReactComponent('ion-menu-toggle');\nconst IonNote =\n/*@__PURE__*/\ncreateReactComponent('ion-note');\nconst IonPickerColumn =\n/*@__PURE__*/\ncreateReactComponent('ion-picker-column');\nconst IonNav =\n/*@__PURE__*/\ncreateReactComponent('ion-nav');\nconst IonProgressBar =\n/*@__PURE__*/\ncreateReactComponent('ion-progress-bar');\nconst IonRadio =\n/*@__PURE__*/\ncreateReactComponent('ion-radio');\nconst IonRadioGroup =\n/*@__PURE__*/\ncreateReactComponent('ion-radio-group');\nconst IonRange =\n/*@__PURE__*/\ncreateReactComponent('ion-range');\nconst IonRefresher =\n/*@__PURE__*/\ncreateReactComponent('ion-refresher');\nconst IonRefresherContent =\n/*@__PURE__*/\ncreateReactComponent('ion-refresher-content');\nconst IonReorder =\n/*@__PURE__*/\ncreateReactComponent('ion-reorder');\nconst IonReorderGroup =\n/*@__PURE__*/\ncreateReactComponent('ion-reorder-group');\nconst IonRippleEffect =\n/*@__PURE__*/\ncreateReactComponent('ion-ripple-effect');\nconst IonRow =\n/*@__PURE__*/\ncreateReactComponent('ion-row');\nconst IonSearchbar =\n/*@__PURE__*/\ncreateReactComponent('ion-searchbar');\nconst IonSegment =\n/*@__PURE__*/\ncreateReactComponent('ion-segment');\nconst IonSegmentButton =\n/*@__PURE__*/\ncreateReactComponent('ion-segment-button');\nconst IonSelect =\n/*@__PURE__*/\ncreateReactComponent('ion-select');\nconst IonSelectOption =\n/*@__PURE__*/\ncreateReactComponent('ion-select-option');\nconst IonSelectPopover =\n/*@__PURE__*/\ncreateReactComponent('ion-select-popover');\nconst IonSkeletonText =\n/*@__PURE__*/\ncreateReactComponent('ion-skeleton-text');\nconst IonSlide =\n/*@__PURE__*/\ncreateReactComponent('ion-slide');\nconst IonSlides =\n/*@__PURE__*/\ncreateReactComponent('ion-slides');\nconst IonSpinner =\n/*@__PURE__*/\ncreateReactComponent('ion-spinner');\nconst IonSplitPane =\n/*@__PURE__*/\ncreateReactComponent('ion-split-pane');\nconst IonText =\n/*@__PURE__*/\ncreateReactComponent('ion-text');\nconst IonTextarea =\n/*@__PURE__*/\ncreateReactComponent('ion-textarea');\nconst IonThumbnail =\n/*@__PURE__*/\ncreateReactComponent('ion-thumbnail');\nconst IonTitle =\n/*@__PURE__*/\ncreateReactComponent('ion-title');\nconst IonToggle =\n/*@__PURE__*/\ncreateReactComponent('ion-toggle');\nconst IonToolbar =\n/*@__PURE__*/\ncreateReactComponent('ion-toolbar');\nconst IonVirtualScroll =\n/*@__PURE__*/\ncreateReactComponent('ion-virtual-scroll');\n\nconst createControllerComponent = (displayName, controller) => {\n  const dismissEventName = \"on\".concat(displayName, \"DidDismiss\");\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.isUnmounted = false;\n    }\n\n    static get displayName() {\n      return displayName;\n    }\n\n    async componentDidMount() {\n      const isOpen = this.props.isOpen;\n\n      if (isOpen) {\n        this.present();\n      }\n    }\n\n    componentWillUnmount() {\n      this.isUnmounted = true;\n\n      if (this.overlay) {\n        this.overlay.dismiss();\n      }\n    }\n\n    async componentDidUpdate(prevProps) {\n      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n        this.present(prevProps);\n      }\n\n      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n        await this.overlay.dismiss();\n      }\n    }\n\n    async present(prevProps) {\n      const _a = this.props,\n            isOpen = _a.isOpen,\n            onDidDismiss = _a.onDidDismiss,\n            cProps = __rest(_a, [\"isOpen\", \"onDidDismiss\"]);\n\n      this.overlay = await controller.create(Object.assign({}, cProps));\n      attachProps(this.overlay, {\n        [dismissEventName]: onDidDismiss\n      }, prevProps); // Check isOpen again since the value could have changed during the async call to controller.create\n      // It's also possible for the component to have become unmounted.\n\n      if (this.props.isOpen === true && this.isUnmounted === false) {\n        await this.overlay.present();\n      }\n    }\n\n    render() {\n      return null;\n    }\n\n  };\n};\n\nconst IonAlert =\n/*@__PURE__*/\ncreateControllerComponent('IonAlert', alertController);\nconst IonLoading =\n/*@__PURE__*/\ncreateControllerComponent('IonLoading', loadingController);\nconst IonToast =\n/*@__PURE__*/\ncreateControllerComponent('IonToast', toastController);\nconst IonPicker =\n/*@__PURE__*/\ncreateControllerComponent('IonPicker', pickerController);\n\nconst createOverlayComponent = (displayName, controller) => {\n  const dismissEventName = \"on\".concat(displayName, \"DidDismiss\");\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.el = document.createElement('div');\n    }\n\n    static get displayName() {\n      return displayName;\n    }\n\n    componentDidMount() {\n      if (this.props.isOpen) {\n        this.present();\n      }\n    }\n\n    componentWillUnmount() {\n      if (this.overlay) {\n        this.overlay.dismiss();\n      }\n    }\n\n    async componentDidUpdate(prevProps) {\n      if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n        this.present(prevProps);\n      }\n\n      if (this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false) {\n        await this.overlay.dismiss();\n      }\n    }\n\n    async present(prevProps) {\n      const _a = this.props,\n            children = _a.children,\n            isOpen = _a.isOpen,\n            _a$onDidDismiss = _a.onDidDismiss,\n            onDidDismiss = _a$onDidDismiss === void 0 ? () => {\n        return;\n      } : _a$onDidDismiss,\n            cProps = __rest(_a, [\"children\", \"isOpen\", \"onDidDismiss\"]);\n\n      const elementProps = Object.assign({}, cProps, {\n        [dismissEventName]: onDidDismiss\n      });\n      const overlay = this.overlay = await controller.create(Object.assign({}, elementProps, {\n        component: this.el,\n        componentProps: {}\n      }));\n      attachProps(overlay, elementProps, prevProps);\n      await overlay.present();\n    }\n\n    render() {\n      return ReactDom.createPortal(this.props.children, this.el);\n    }\n\n  };\n};\n\nconst IonActionSheet =\n/*@__PURE__*/\ncreateOverlayComponent('IonActionSheet', actionSheetController);\nconst IonModal =\n/*@__PURE__*/\ncreateOverlayComponent('IonModal', modalController);\nconst IonPopover =\n/*@__PURE__*/\ncreateOverlayComponent('IonPopover', popoverController);\n\nconst IonPage =\n/*@__PURE__*/\n(() => class IonPageInternal extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.ref = React.createRef();\n  }\n\n  componentDidMount() {\n    if (this.context && this.ref.current) {\n      if (this.context.hasIonicRouter()) {\n        this.context.registerIonPage(this.ref.current);\n      }\n    }\n  }\n\n  render() {\n    const _a = this.props,\n          className = _a.className,\n          children = _a.children,\n          props = __rest(_a, [\"className\", \"children\"]);\n\n    return React.createElement(\"div\", Object.assign({\n      className: className ? \"ion-page \".concat(className) : 'ion-page',\n      ref: this.ref\n    }, props), children);\n  }\n\n  static get displayName() {\n    return 'IonPage';\n  }\n\n  static get contextType() {\n    return NavContext;\n  }\n\n})();\n\nconst IonTabBarInner =\n/*@__PURE__*/\ncreateReactComponent('ion-tab-bar');\nconst IonBackButtonInner =\n/*@__PURE__*/\ncreateReactComponent('ion-back-button');\nconst IonRouterOutletInner =\n/*@__PURE__*/\ncreateReactComponent('ion-router-outlet');\n\nconst IonRouterOutletContainer =\n/*@__PURE__*/\n(() => class extends React.Component {\n  render() {\n    const StackManager = this.context.getStackManager();\n    return this.context.hasIonicRouter() ? React.createElement(StackManager, null, React.createElement(IonRouterOutletInner, Object.assign({\n      ref: this.props.forwardedRef\n    }, this.props), this.props.children)) : React.createElement(IonRouterOutletInner, Object.assign({\n      ref: this.props.forwardedRef\n    }, this.props), this.props.children);\n  }\n\n  static get contextType() {\n    return NavContext;\n  }\n\n})();\n\nconst IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');\n\nconst IonTabBarUnwrapped =\n/*@__PURE__*/\n(() => class extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.onTabButtonClick = e => {\n      if (this.state.activeTab === e.detail.tab) {\n        const originalHref = this.state.tabs[e.detail.tab].originalHref;\n\n        if (this.context.hasIonicRouter()) {\n          this.context.tabNavigate(originalHref);\n        } else {\n          this.context.navigate(originalHref, 'back');\n        }\n      } else {\n        if (this.props.onIonTabsWillChange) {\n          this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', {\n            detail: {\n              tab: e.detail.tab\n            }\n          }));\n        }\n\n        if (this.props.onIonTabsDidChange) {\n          this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', {\n            detail: {\n              tab: e.detail.tab\n            }\n          }));\n        }\n\n        this.context.navigate(this.state.tabs[e.detail.tab].currentHref, 'none');\n      }\n    };\n\n    this.renderChild = activeTab => child => {\n      if (child != null && child.props && child.type === IonTabButton) {\n        const href = child.props.tab === activeTab ? this.props.currentPath : this.state.tabs[child.props.tab].currentHref;\n        return React.cloneElement(child, {\n          href,\n          onIonTabButtonClick: this.onTabButtonClick\n        });\n      }\n\n      return null;\n    };\n\n    const tabActiveUrls = {};\n    React.Children.forEach(this.props.children, child => {\n      if (child != null && typeof child === 'object' && child.props && child.type === IonTabButton) {\n        tabActiveUrls[child.props.tab] = {\n          originalHref: child.props.href,\n          currentHref: child.props.href\n        };\n      }\n    });\n    this.state = {\n      activeTab: undefined,\n      tabs: tabActiveUrls\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    const activeTab = Object.keys(state.tabs).find(key => {\n      const href = state.tabs[key].originalHref;\n      return props.currentPath.startsWith(href);\n    });\n\n    if (activeTab === undefined || activeTab === state.activeTab && state.tabs[activeTab].currentHref === props.currentPath) {\n      return null;\n    }\n\n    return {\n      activeTab,\n      tabs: Object.assign({}, state.tabs, {\n        [activeTab]: {\n          originalHref: state.tabs[activeTab].originalHref,\n          currentHref: props.currentPath\n        }\n      })\n    };\n  }\n\n  render() {\n    return React.createElement(IonTabBarInner, Object.assign({}, this.props, {\n      selectedTab: this.state.activeTab\n    }), React.Children.map(this.props.children, this.renderChild(this.state.activeTab)));\n  }\n\n  static get contextType() {\n    return NavContext;\n  }\n\n})();\n\nconst IonTabBar = props => {\n  const context = useContext(NavContext);\n  return React.createElement(IonTabBarUnwrapped, Object.assign({}, props, {\n    currentPath: props.currentPath || context.currentPath\n  }), props.children);\n};\n\nconst hostStyles = {\n  display: 'flex',\n  position: 'absolute',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  flexDirection: 'column',\n  width: '100%',\n  height: '100%',\n  contain: 'layout size style'\n};\nconst tabsInner = {\n  position: 'relative',\n  flex: 1,\n  contain: 'layout size style'\n};\n\nclass IonTabs extends React.Component {\n  constructor(props) {\n    super(props);\n    this.routerOutletRef = React.createRef();\n  }\n\n  render() {\n    let outlet;\n    let tabBar;\n    React.Children.forEach(this.props.children, child => {\n      if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {\n        return;\n      }\n\n      if (child.type === IonRouterOutlet) {\n        outlet = child;\n      }\n\n      if (child.type === IonTabBar) {\n        const _this$props2 = this.props,\n              onIonTabsDidChange = _this$props2.onIonTabsDidChange,\n              onIonTabsWillChange = _this$props2.onIonTabsWillChange;\n        tabBar = React.cloneElement(child, {\n          onIonTabsDidChange,\n          onIonTabsWillChange\n        });\n      }\n    });\n\n    if (!outlet) {\n      throw new Error('IonTabs must contain an IonRouterOutlet');\n    }\n\n    if (!tabBar) {\n      // TODO, this is not required\n      throw new Error('IonTabs needs a IonTabBar');\n    }\n\n    return React.createElement(\"div\", {\n      style: hostStyles\n    }, tabBar.props.slot === 'top' ? tabBar : null, React.createElement(\"div\", {\n      style: tabsInner,\n      className: \"tabs-inner\"\n    }, outlet), tabBar.props.slot === 'bottom' ? tabBar : null);\n  }\n\n  static get contextType() {\n    return NavContext;\n  }\n\n}\n\nconst IonBackButton =\n/*@__PURE__*/\n(() => class extends React.Component {\n  constructor() {\n    super(...arguments);\n\n    this.clickButton = e => {\n      const defaultHref = this.props.defaultHref;\n\n      if (this.context.hasIonicRouter()) {\n        e.stopPropagation();\n        this.context.goBack(defaultHref);\n      } else if (defaultHref !== undefined) {\n        window.location.href = defaultHref;\n      }\n    };\n  }\n\n  render() {\n    return React.createElement(IonBackButtonInner, Object.assign({\n      onClick: this.clickButton\n    }, this.props));\n  }\n\n  static get displayName() {\n    return 'IonBackButton';\n  }\n\n  static get contextType() {\n    return NavContext;\n  }\n\n})(); // Icons that are used by internal components\n\n\naddIcons({\n  'ios-close': close.ios,\n  'md-close': close.md,\n  'ios-reorder': reorder.ios,\n  'md-reorder': reorder.md,\n  'ios-menu': menu.ios,\n  'md-menu': menu.md,\n  'ios-arrow-forward': arrowForward.ios,\n  'md-arrow-forward': arrowForward.md,\n  'ios-arrow-back': arrowBack.ios,\n  'md-arrow-back': arrowBack.md,\n  'ios-arrow-down': arrowDown.ios,\n  'md-arrow-down': arrowDown.md,\n  'ios-search': search.ios,\n  'md-search': search.md,\n  'ios-close-circle': closeCircle.ios,\n  'md-close-circle': closeCircle.md\n}); // TODO: defineCustomElements() is asyncronous\n// We need to use the promise\n\ndefineCustomElements(window);\nexport { DefaultIonLifeCycleContext, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonLifeCycleContext, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNote, IonPage, IonPicker, IonPickerColumn, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSelectPopover, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, NavContext, getConfig, getPlatforms, isPlatform, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle };","map":null,"metadata":{},"sourceType":"module"}